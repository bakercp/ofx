#!/usr/bin/env bash
set -e

#set -x # run script in debug mode
set -o pipefail  # Trace ERR through pipes.
set -o errtrace  # Trace ERR through 'time command' and other functions.
set -o nounset   # set -u : exit the script if you try to use an uninitialized variable.
set -o errexit   # set -e : exit the script if any statement returns a non-true return value.

# Helpful env variables.
DEFAULT_CLONE_DEPTH=1
# export MAKEFLAGS="-s"

JOBS=$(nproc --ignore=1)

# Is verbose?
_VERBOSE=0

HELP="usage: ofx [options] <command> [command parameters]
about:
 This is ofx, the openFrameworks addons multi-tool.
commands:
  bootstrap clean generate install list
options:
  -j The number of jobs (cores) used when compiling (default: 1).
  -t The target platform.
  -p The Project Generator command-line app path.
  -o The openFrameworks root path.
  -h or -? Print this usage guide.
  -v Verbose Mode.
examples:
  ./ofx bootstrap
"

# Trap the killer signals so that we can exit with a good message
trap "trapSignal SIGHUP" SIGHUP
trap "trapSignal SIGINT" SIGINT
trap "trapSignal SIGTERM" SIGTERM

trapSignal() { echo; echoError " Received signal $1"; exit 1; }

# trap any script errors and exit
trap "trapError" ERR

trapError() { echo; echoError " ^ Received error ^"; exit 1; }

# ANSI console escape codes.
CON_DEFAULT="\033[0m"
CON_BOLD="\033[1m"
CON_RED="\033[31m"
CON_YELLOW="\033[33m"
CON_GREEN="\033[32m"
CON_YELLOW_UNDERLINE="\033[33;1;4m"

# Console printing functions (with color)
echoError()   { echo -e "‚ùå  $CON_BOLD$CON_RED$1$CON_DEFAULT"; }
echoWarning() { echo -e "‚ö†Ô∏è  $CON_BOLD$CON_YELLOW$1$CON_DEFAULT"; }
echoInfo()    { echo -e "‚ÑπÔ∏è  $CON_BOLD$1$CON_DEFAULT"; }
echoSuccess() { echo -e "‚úÖ  $CON_BOLD$CON_GREEN$1$CON_DEFAULT"; }
echoVerbose() { if [ $_VERBOSE == 1 ] ; then echoInfo "$1"; fi }
echoFancy() { echo -e "üí™  ${1} $CON_YELLOW_UNDERLINE${2}$CON_DEFAULT ..."; }

# \brief Convert a string to lower case.
# \param $1 A string.
# \returns a lowercase string an a 0 exit code on success.
function lowercase()
{
  echo "${1}" | sed "y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/"
  return 0
}

# \brief Get the openFrameworks name of the host operating system.
# \returns a string an a 0 exit code on success.
function os()
{
  local OS
  OS="$(lowercase "$(uname)")"

  if [ "${OS}" == "darwin" ]; then
    OS="osx"
  elif [ "${OS}" == "windowsnt" ] ; then
    OS="vs"
  elif [ "${OS:0:5}" == "mingw" ] || [ "${OS}" == "msys_nt-6.3" ]; then
    OS="msys2"
  elif [ "${OS}" == "linux" ]; then
    ARCH=`uname -m`
    if [ "${ARCH}" == "i386" ] || [ "${ARCH}" == "i686" ] ; then
      OS="linux"
    elif [ "${ARCH}" == "x86_64" ] ; then
      OS="linux64"
    elif [ "${ARCH}" == "armv6l" ] ; then
      OS="linuxarmv6l"
    elif [ "${ARCH}" == "armv7l" ] ; then
      # Make an exception for raspberry pi to run on armv6l, to conform
      # with openFrameworks.
      if [ -f /opt/vc/include/bcm_host.h ]; then
        OS="linuxarmv6l"
      else
        OS="linuxarmv7l"
      fi
    else
      # We don't know this one, but we will try to make a reasonable guess.
      OS="linux"${ARCH}
    fi
  fi
  echo ${OS}
  return 0
}

# \brief Get the openFrameworks name of the host operating system.
# \param $1 The space-delimited string to de-duplicated and sort.
# \returns a string an a 0 exit code on success.
function sort_and_remove_duplicates()
{
    echo $(echo ${1} | tr ' ' '\n' | sort -u | tr '\n' ' ')
    return 0
}

# \brief Compare two files using cmp.
# \param $1 The first file.
# \param $2 The second file.
# \returns a "1" on match or a "0" on failure and a 0 exit code on success.
function is_same_file()
{
  cmp --silent $1 $2 && echo "1" || echo "0"
  return 0;
}

# Tutorial: https://wiki.bash-hackers.org/howto/getopts_tutorial

# A POSIX variable
OPTIND=1 # Reset in case getopts has been used previously in the shell.

# When a colon is after an character, that character expects an argument.
while getopts j:p:t:o:hv opt ; do
  case "$opt" in
    j) JOBS=$OPTARG ; ;;
    p) OF_PROJECT_GENERATOR_BIN_PATH=$OPTARG ; ;;
    t) TARGET_PLATFORM=$OPTARG ; ;;
    o) OF_ROOT=$OPTARG ; ;;
    h|\?) echoInfo "$HELP" ; exit 1 ;;
    v) _VERBOSE=1 ;;
  esac
done
shift "$((OPTIND-1))"

# Get command.
if [ $# -gt 0 ] ; then
  A_CMD=$1
else
  echoWarning "Missing command. See help: '$0 -h'."
  exit 1
fi

shift 1

# Some commands don't require targets.
if ! [ "$A_CMD" == "bootstrap" ]; then
  # check for arguments
  if [ $# -lt 1 ] ; then
    echoError " Missing command target. See help: 'ofx -h'."
    exit 1
  fi
fi

# Determine the platform being used.
HOST_PLATFORM=${HOST_PLATFORM:-$(os)}
TARGET_PLATFORM=${TARGET_PLATFORM:-$(os)}

# Account for local addons.
IS_LOCAL_ADDON=false

ADDON_PARENT_DIRECTORY=$(basename "$(cd "$( dirname "${BASH_SOURCE[0]}" )/../../.." && pwd)")
if [ "${ADDON_PARENT_DIRECTORY}" == "local_addons" ]; then
  THIS_ADDON_PATH=$(cd "$( dirname "${BASH_SOURCE[0]}" )/../.." && pwd)
  IS_LOCAL_ADDON=true
fi

# Set defaults based on environment.
_CI=${CI:-}
_APPVEYOR=${APPVEYOR:-}
_TRAVIS=${TRAVIS:-}

# This script should live in the scripts directory of the addon.
if [ ! -z ${_CI} ] && [ "$_CI" == "true" ]; then
  OF_ROOT=${OF_ROOT:-~/openFrameworks}
  if [ ! -z ${_APPVEYOR} ] && [ "$_APPVEYOR" == "true" ]; then
    THIS_ADDON_NAME=${APPVEYOR_PROJECT_SLUG#*/}
    THIS_USERNAME=${APPVEYOR_PROJECT_SLUG%/*}
    THIS_BRANCH=${APPVEYOR_REPO_BRANCH}
  elif [ ! -z ${_TRAVIS} ] && [ "$_TRAVIS" == "true" ]; then
    THIS_ADDON_NAME=${TRAVIS_REPO_SLUG#*/}
    THIS_USERNAME=${TRAVIS_REPO_SLUG%/*}
    THIS_BRANCH=${TRAVIS_BRANCH}
  fi
else
  if [ "$IS_LOCAL_ADDON" == "true" ]; then
    OF_ROOT=${OF_ROOT:-$(cd "$( dirname "${BASH_SOURCE[0]}" )/../../../../../../../" && pwd)}
  else
    OF_ROOT=${OF_ROOT:-$(cd "$( dirname "${BASH_SOURCE[0]}" )/../../../../" && pwd)}
  fi
  THIS_ADDON_NAME=$(basename "$(cd "$( dirname "${BASH_SOURCE[0]}" )/../.."  && pwd)")
  THIS_USERNAME=$(whoami)
  THIS_BRANCH=$(git rev-parse --abbrev-ref HEAD)
fi

# Account for local addons.
ADDON_PARENT_DIRECTORY=$(basename "$(cd "$( dirname "${BASH_SOURCE[0]}" )/../../.." && pwd)")
if [ "${ADDON_PARENT_DIRECTORY}" == "local_addons" ]; then
  THIS_ADDON_PATH=$(cd "$( dirname "${BASH_SOURCE[0]}" )/../.." && pwd)
fi

# OF paths.
OF_ADDONS_PATH=${OF_ADDONS_PATH:-${OF_ROOT}/addons}
OF_SCRIPTS_PATH=${OF_SCRIPTS_PATH:-${OF_ROOT}/scripts}
OF_APOTHECARY_PATH=${OF_APOTHECARY_PATH:-${OF_SCRIPTS_PATH}/apothecary}

# Addon paths.
THIS_ADDON_PATH=${THIS_ADDON_PATH:-${OF_ADDONS_PATH}/${THIS_ADDON_NAME}}
THIS_ADDON_SHARED_PATH=${THIS_ADDON_SHARED_PATH:-${THIS_ADDON_PATH}/shared}
THIS_ADDON_SHARED_DATA_PATH=${THIS_ADDON_SHARED_DATA_PATH:-${THIS_ADDON_SHARED_PATH}/data}
THIS_ADDON_SCRIPTS_PATH=${THIS_ADDON_SCRIPTS_PATH:-${THIS_ADDON_PATH}/scripts}

# OF Clone info.
OF_CLONE_DEPTH=${OF_CLONE_DEPTH:-${DEFAULT_CLONE_DEPTH}}
OF_CLONE_BRANCH=${OF_CLONE_BRANCH:-${THIS_BRANCH}}
OF_CLONE_USERNAME=${OF_CLONE_USERNAME:-openFrameworks}

# Addon Clone info.
ADDON_CLONE_DEPTH=${ADDON_CLONE_DEPTH:-${DEFAULT_CLONE_DEPTH}}
ADDON_CLONE_BRANCH=${ADDON_CLONE_BRANCH:-${THIS_BRANCH}}
ADDON_CLONE_USERNAME=${ADDON_CLONE_USERNAME:-${THIS_USERNAME}}

# Project generator info.

if [ "${HOST_PLATFORM}" == "osx" ]; then
  OF_PROJECT_GENERATOR_PATH=${OF_PROJECT_GENERATOR_PATH:-$OF_ROOT/projectGenerator_${HOST_PLATFORM}}
else
  OF_PROJECT_GENERATOR_PATH=${OF_PROJECT_GENERATOR_PATH:-$OF_ROOT/projectGenerator-${HOST_PLATFORM}}
fi

if [ -z ${OF_PROJECT_GENERATOR_BIN_PATH+x} ]; then
    if [ "${HOST_PLATFORM}" == "osx" ]; then
      OF_PROJECT_GENERATOR_BIN_PATH=${OF_PROJECT_GENERATOR_PATH}/projectGenerator.app/Contents/Resources/app/app
    else
      OF_PROJECT_GENERATOR_BIN_PATH=${OF_PROJECT_GENERATOR_PATH}/resources/app/app
    fi
fi

OF_PROJECT_GENERATOR_BIN=projectGenerator
OF_PROJECT_GENERATOR_COMMAND=${OF_PROJECT_GENERATOR_BIN_PATH}/./${OF_PROJECT_GENERATOR_BIN}

if [ -f ${OF_PROJECT_GENERATOR_COMMAND} ]; then
  OF_PROJECT_GENERATOR_AVAILABLE=true
else
  OF_PROJECT_GENERATOR_AVAILABLE=false
fi

if [ $_VERBOSE == 1 ]; then
  echo "================================================================================"
  echo ""
  echo "                          IS_LOCAL_ADDON: ${IS_LOCAL_ADDON}"
  echo "                           HOST_PLATFORM: ${HOST_PLATFORM}"
  echo "                         TARGET_PLATFORM: ${TARGET_PLATFORM}"
  echo ""
  echo "                                     _CI: ${_CI}"
  echo "                               _APPVEYOR: ${_APPVEYOR}"
  echo "                                 _TRAVIS: ${_TRAVIS}"
  echo ""
  echo "                                 OF_ROOT: ${OF_ROOT}"
  echo "                          OF_ADDONS_PATH: ${OF_ADDONS_PATH}"
  echo "                         OF_SCRIPTS_PATH: ${OF_SCRIPTS_PATH}"
  echo "                      OF_APOTHECARY_PATH: ${OF_APOTHECARY_PATH}"
  echo "               OF_PROJECT_GENERATOR_PATH: ${OF_PROJECT_GENERATOR_PATH}"
  echo "           OF_PROJECT_GENERATOR_BIN_PATH: ${OF_PROJECT_GENERATOR_BIN_PATH}"
  echo "                OF_PROJECT_GENERATOR_BIN: ${OF_PROJECT_GENERATOR_BIN}"
  echo "          OF_PROJECT_GENERATOR_AVAILABLE: ${OF_PROJECT_GENERATOR_AVAILABLE}"
  echo ""
  echo "                         THIS_ADDON_NAME: ${THIS_ADDON_NAME}"
  echo "                         THIS_ADDON_PATH: ${THIS_ADDON_PATH}"
  echo "             THIS_ADDON_SHARED_DATA_PATH: ${THIS_ADDON_SHARED_DATA_PATH}"
  echo "                 THIS_ADDON_SCRIPTS_PATH: ${THIS_ADDON_SCRIPTS_PATH}"
  echo ""
  echo "                           THIS_USERNAME: ${THIS_USERNAME}"
  echo "                             THIS_BRANCH: ${THIS_BRANCH}"
  echo ""
  echo "                          OF_CLONE_DEPTH: ${OF_CLONE_DEPTH}"
  echo "                         OF_CLONE_BRANCH: ${OF_CLONE_BRANCH}"
  echo "                       OF_CLONE_USERNAME: ${OF_CLONE_USERNAME}"
  echo ""
  echo "                       ADDON_CLONE_DEPTH: ${ADDON_CLONE_DEPTH}"
  echo "                      ADDON_CLONE_BRANCH: ${ADDON_CLONE_BRANCH}"
  echo "                    ADDON_CLONE_USERNAME: ${ADDON_CLONE_USERNAME}"
  echo ""
  echo "                                    JOBS: ${JOBS}"
  echo "                                _VERBOSE: ${_VERBOSE}"
  echo ""
  echo "================================================================================"
fi

################################################################################
# Functions
################################################################################

# \brief Clean all project files from the given project.
# \param $1 The project to clean.
# \param $2 (optional) To force clean all project files.
# \returns 0 exit code on success.
function clean_project_files()
{
  local FORCE_CLEAN=false

  if [ $# -gt 1 ] && [ "$2" == "force" ]; then
    FORCE_CLEAN=true
  fi

  if [ "${FORCE_CLEAN}" == "true" ]; then
    # Here we force clean the makefiles and config.make.
    find $1 -maxdepth 1 \
    \( \
          -name "*.qbs" \
      -o -name "*.xcodeproj" \
      -o -name "*.xcconfig" \
      -o -name "*.plist" \
      -o -name "*.qbs.user" \
      -o -name "config.make" \
      -o -name "Makefile" \
    \) \
    -exec rm -rf {} \;
  else
    find $1 -maxdepth 1 \
    \( \
          -name "*.qbs" \
      -o -name "*.xcodeproj" \
      -o -name "*.xcconfig" \
      -o -name "*.plist" \
      -o -name "*.qbs.user" \
    \) \
    -exec rm -rf {} \;
  fi

  echoSuccess "Cleaned Project Files For: $1"

  return 0;
}


# \brief Clean all build files from the given project.
# \param $1 The project to clean.
# \param $2 (optional) To force clean all build files.
# \returns 0 exit code on success.
function clean_project_build_files()
{
  local FORCE_CLEAN=false

  if [ $# -gt 1 ] && [ "$2" == "force" ]; then
    FORCE_CLEAN=true
  fi

  # QTCreatorBuild paths
  find $1 -maxdepth 1 \( \
      -type d -a \
      -name "build-example*" \
    \)  -exec rm -rf {} \;

  find $1 -maxdepth 1 \( \
        -type d -a \
        -name "_obj*" \
    \)  -exec rm -rf {} \;

  # Project build files
  find $1 -maxdepth 1 \( \
      -type d -a \
      -name "obj" \
    \)  -exec rm -rf {} \;

  if [ -d $1/bin ] ; then
    # Project app files
    find $1/bin -maxdepth 1 \( \
        -name "*.app" \
      -o -name "*.app.dSYM" \
      -o -name "PkgInfo" \
      -o -name ".tmp" \
      -o -name "*.plist" \
      \)  -exec rm -rf {} \;
  fi
  echoSuccess "Cleaned Build Files For: $1"

  return 0;
}

function find_projects()
{
  # Here we just print the parent directory. -printf '%h\n' is the same as -exec dirname {} \;
  # \returns 0 exit code on success.
  echo $(find $1 -name addons.make -printf '%h\n')
  return 0
}

function find_example_projects()
{
  echo $(find_projects $1/example*)
  return 0
}

# \brief Print every test folder with a valid addons.make path.
function get_tests()
{
  echo $(find_projects $1/tests)
  return 0
}


function clean_example_project_files()
{
  echoFancy "Cleaning" "Example Project Files"

  for project in $(get_examples); do
    clean_project_files "${project}" $@
  done
}


function clean_test_project_files()
{
  echoFancy "Cleaning" "Test Project Files"

  while read project; do
    clean_project_files ${project} $@
  done <<< $(find ${THIS_ADDON_PATH}/tests -name addons.make -exec dirname {} \;)

}


function clean_example_build_files()
{
  echoFancy "Cleaning" "Example Build Files"

  while read project; do
    clean_project_build_files ${project} $@
  done <<< $(find ${THIS_ADDON_PATH}/example* -name addons.make -exec dirname {} \;)

  return 0;
}


function clean_test_build_files()
{
  echoFancy "Cleaning" "Test Build Files"

  while read project; do
    clean_project_build_files ${project} $@
  done <<< $(find ${THIS_ADDON_PATH}/tests -name addons.make -exec dirname {} \;)

  return 0;
}


function clean_apothecary()
{
  if ! [ -f ${OF_APOTHECARY_PATH}/apothecary/apothecary ] ; then
    echoError "Apothecary not installed."
    exit 1;
  fi

  echoFancy "Building " "${THIS_ADDON_NAME} libraries for ${TARGET_PLATFORM}"
  /usr/bin/env bash ${OF_APOTHECARY_PATH}/apothecary/apothecary -j ${JOBS} -t "${TARGET_PLATFORM}" -d "${THIS_ADDON_PATH}/libs" clean "${THIS_ADDON_NAME}"
  echoSuccess "Apothecary cleaning of ${THIS_ADDON_NAME} for ${TARGET_PLATFORM} complete."
}


function install_apothecary()
{
  # Check to see if apothecary is already installed.
  if ! [ -f ${OF_APOTHECARY_PATH}/apothecary/apothecary ] ; then
    echoInfo "Apothecary not installed, pulling latest version."
    git clone https://github.com/openframeworks/apothecary.git ${OF_APOTHECARY_PATH}/
  else
    pushd "${OF_APOTHECARY_PATH}/" > /dev/null
    if git rev-parse --is-inside-work-tree ; then
        echoInfo "Apothecary is under git control, updating."
        git pull origin master
    else
        echoWarning "Apothecary is not under git control, so it may not be up-to-date."
    fi
    popd > /dev/null
  fi

  if [ "${HOST_PLATFORM}" == "osx" ]; then
    if ! [ -x "$(command -v brew)" ]; then
      echoError "Brew is not installed. Go here and install it: https://brew.sh/." >&2
      exit 1
    else
      echoInfo "Brew is installed, continuing."
    fi

    if xcrun -sdk iphoneos --show-sdk-version ; then
      echoInfo "macOS iOS SDK Found"
    else
      echoError "The SDK path is not set correctly ..."

      if ! [ -e "/Applications/Xcode.app/Contents/Developer" ]; then
        echoError "Xcode is NOT installed."
        echoError "Install it from the App Store, then open the application and agree to the license."
      else
        echoError "Xcode is installed, so try running:"
        echo ""
        echoWarning "    sudo xcode-select -s /Applications/Xcode.app/Contents/Developer/"
        echo ""
        echoWarning "    Or ..."
        echo ""
        echoWarning "    1) Open Xcode Preferences ..."
        echoWarning "    2) Got to the Locations tab ..."
        echoWarning "    3) Make sure the Command Line Tools are set to the latest version ..."
        echo ""
      fi

      echoError "Then run this command again."

      exit 1
    fi
  fi

  # Install any apothecary dependencies.
  if [ -f ${OF_APOTHECARY_PATH}/scripts/${HOST_PLATFORM}/install.sh ] ; then
    echoFancy "Installing" "Apothecary Dependencies"
    /usr/bin/env bash ${OF_APOTHECARY_PATH}/scripts/${HOST_PLATFORM}/install.sh
  else
    echoInfo "No additional apothecary dependencies to install."
  fi

  echoSuccess "Done installing apothecary."
  return 0;
}


# Extract ADDON_DEPENDENCIES from an addon's addon_config.mk file.
function get_addon_dependencies_from_addon_config_mk()
{
  if [ -f ${THIS_ADDON_PATH}/addon_config.mk ]; then
    local ADDON_DEPENDENCIES=""
    while read line; do
      if [[ $line == ADDON_DEPENDENCIES* ]] ;
      then
        line=${line#*=}
        IFS=' ' read -ra ADDR <<< "$line"
        for i in "${ADDR[@]}"; do
          ADDON_DEPENDENCIES="${ADDON_DEPENDENCIES} ${i}"
        done
      fi
    done < ${THIS_ADDON_PATH}/addon_config.mk
    echo $(sort_and_remove_duplicates "${ADDON_DEPENDENCIES}")
  fi
  return 0
}


# Extract ADDON_DEPENDENCIES from an project's addons.make files.
function get_addon_dependencies_from_project()
{
  local ADDON_DEPENDENCIES=""
  while read addon; do
    ADDON_DEPENDENCIES="${ADDON_DEPENDENCIES} ${addon}"
  done < $1/addons.make
  echo $(sort_and_remove_duplicates "${ADDON_DEPENDENCIES}")
  return 0
}

function get_addon_dependencies_from_all_examples()
{
  local ADDON_DEPENDENCIES=""
  while read project; do
    ADDON_DEPENDENCIES="${ADDON_DEPENDENCIES} $(get_addon_dependencies_from_project "${project}")"
  done <<< $(find ${THIS_ADDON_PATH}/example* -name addons.make -exec dirname {} \;)
  echo $(sort_and_remove_duplicates "${ADDON_DEPENDENCIES}")
  return 0
}


function get_addon_dependencies_from_all_tests()
{
  local ADDON_DEPENDENCIES=""
  while read project; do
    ADDON_DEPENDENCIES="${ADDON_DEPENDENCIES} $(get_addon_dependencies_from_project "${project}")"
  done <<< $(find ${THIS_ADDON_PATH}/tests -name addons.make -exec dirname {} \;)
  echo $(sort_and_remove_duplicates "${ADDON_DEPENDENCIES}")
  return 0
}


function get_addon_dependencies_from_all_projects()
{
  echo $(sort_and_remove_duplicates "$(get_addon_dependencies_from_all_examples) $(get_addon_dependencies_from_all_tests)")
  return 0
}

function get_all_addon_dependencies()
{
  echo $(sort_and_remove_duplicates "$(get_addon_dependencies_from_addon_config_mk) $(get_addon_dependencies_from_all_projects)")
  return 0
}



function install_dependencies()
{
  echoFancy "Installing" "System Dependencies"

  if [ -f ${THIS_ADDON_PATH}/scripts/${TARGET_PLATFORM}/install.sh ] ; then
    /usr/bin/env bash ${THIS_ADDON_PATH}/scripts/${TARGET_PLATFORM}/install.sh
  fi

  echoFancy "Installing" "3rd Party Libraries"

  if ! [ -f ${OF_APOTHECARY_PATH}/apothecary/apothecary ] ; then
    echoError "Apothecary not installed."
    exit 1;
  fi

  echoFancy "Building " "${THIS_ADDON_NAME} libraries for ${TARGET_PLATFORM}"
  /usr/bin/env bash ${OF_APOTHECARY_PATH}/apothecary/apothecary -j${JOBS} -t "${TARGET_PLATFORM}" -d "${THIS_ADDON_PATH}/libs" update "${THIS_ADDON_NAME}"
  echoSuccess "Build of ${THIS_ADDON_NAME} for ${TARGET_PLATFORM} complete."
  return 0;
}


function install_shared_data()
{
  echoFancy "Installing" "shared data"

  if [ -d ${THIS_ADDON_SHARED_DATA_PATH} ] ; then
    SHARED_DATA_SCRIPTS=$(find ${THIS_ADDON_SHARED_DATA_PATH} -name *.sh)
    for script in ${SHARED_DATA_SCRIPTS}; do
      /usr/bin/env bash ${script}
    done
  fi

  return 0;
}


function install_data_for_project()
{
    PROJECT_PATH=$1
    local did_install=false
    if [ -d ${PROJECT_PATH}/bin/data ] ; then

      DATA_FILES=$(find ${PROJECT_PATH}/bin/data -name data.txt)
      for data_file in ${DATA_FILES}
      do
        did_install=true
        # For the project data path.
        THIS_PROJECT_BIN_DATA_PATH=$(dirname "${data_file}")

        # The || [ -n "$line" ]; is to help when the last line isn't a new line char.
        while read line || [ -n "$line" ];
        do
          # Make sure the data doesn't start with a comment hash #
          # Make sure that it isn't am empty line.
          if [ "${line:0:1}" != "#"  ] && [ -n "${line// }" ]; then
            IFS=' ' read -r -a tokens <<< "${line}" # Parse the tokens.
            SRC=${tokens[0]} # Get the source location.
            DST=${tokens[1]:-""} # Get the destination location, or nothing if missing.

            if ! [[ ${SRC} == http* ]]; then
              if [[ ${SRC} == /* ]]; then
                SRC_PATH=${SRC}
              else
                SRC_PATH=${THIS_ADDON_SHARED_DATA_PATH}/${SRC}
              fi

              if [[ -z ${DST} ]]; then
                if [[ ${SRC} == /* ]]; then
                  DST_PATH=${THIS_PROJECT_BIN_DATA_PATH}/$(basename "${SRC}")
                else
                  DST_PATH=${THIS_PROJECT_BIN_DATA_PATH}/${SRC}
                fi
              else
                DST_PATH=${THIS_PROJECT_BIN_DATA_PATH}/${DST}
              fi

              if ! [ -e ${DST_PATH} ]; then
                if ! [ -e ${SRC_PATH} ]; then
                  echo "‚ùå ${SRC_PATH} does not exist. Did you install the shared data?"
                  continue
                fi

                mkdir -p "$(dirname "${DST_PATH}")"
                rsync -Pvqar ${SRC_PATH} ${DST_PATH}
              fi

              echo "‚úÖ ${SRC_PATH} üëâ ${DST_PATH}"
            else
              if [[ -z ${DST} ]]; then
                DST=$(basename ${SRC})
              fi
              DST_PATH=${THIS_PROJECT_BIN_DATA_PATH}/${DST}
              if ! [ -e ${DST_PATH} ]; then
                curl --progress-bar --create-dirs -o ${DST_PATH} -L ${SRC}
              fi
              echo "‚úÖ ${SRC} üëâ ${DST_PATH}"
            fi
          fi
        done < ${data_file}
      done
    fi

    if [ ${did_install} == "true" ]; then
      echoSuccess "Installed data for: ${PROJECT_PATH#"${THIS_ADDON_PATH}/"}"
    else
      echoInfo "No shared data for: ${PROJECT_PATH#"${THIS_ADDON_PATH}/"}"
    fi
}


function install_example_data()
{
  echoFancy "Installing" "example data"
  while read project; do
    install_data_for_project ${project}
  done <<< $(find ${THIS_ADDON_PATH}/example* -name addons.make -exec dirname {} \;)
  return 0;
}


function install_test_data()
{
  echoFancy "Installing" "test data"
  while read project; do
    install_data_for_project ${project}
  done <<< $(find ${THIS_ADDON_PATH}/tests -name addons.make -exec dirname {} \;)
  return 0;
}


function list_examples()
{
  echoFancy "Listing" "examples"

  while read project; do
    echo ${project}
  done <<< $(find ${THIS_ADDON_PATH}/example* -name addons.make -exec dirname {} \;)
}


function list_addon_dependencies()
{
  echoFancy "Listing" "addon dependencies"

  get_all_addon_dependencies
}


function list_tests()
{
  echoFancy "Listing" "tests"

  while read project; do
    echo ${project}
  done <<< $(find ${THIS_ADDON_PATH}/tests -name addons.make -exec dirname {} \;)

}


function list()
{
  case "$1" in
    examples) shift 1; list_examples "$@" ;;
    addon_dependencies) shift 1; list_addon_dependencies "$@" ;;
    tests) shift 1; list_tests "$@" ;;
    *)
      echoError " Unknown list target: \"$1\""
      echoError " valid: examples, addon_dependencies, tests"
      exit 1 ;;
  esac
  return 0;
}


function clean()
{
  case "$1" in
    all)
      shift 1
      clean_apothecary "$@"
      clean_example_project_files "$@"
      clean_test_project_files "$@"
      clean_example_build_files "$@"
      clean_test_build_files "$@"
      ;;
    apothecary) shift 1; clean_apothecary "$@" ;;
    example_project_files) shift 1; clean_example_project_files "$@" ;;
    test_project_files) shift 1; clean_test_project_files "$@" ;;
    example_build_files) shift 1; clean_example_build_files "$@" ;;
    test_build_files) shift 1; clean_example_build_files "$@" ;;
    projects)
      shift 1
      clean_example_project_files "$@"
      clean_test_project_files "$@"
      ;;
    build)
      shift 1
      clean_example_build_files "$@"
      clean_test_build_files "$@"
      ;;
    *)
      echoError " Unknown clean target: \"$1\""
      echoError " valid: all, apothecary, example_project_files, test_project_files, example_build_files, test_build_files, projects, build"
      exit 1 ;;
  esac
  return 0;
}


function install()
{
  case "$1" in
    apothecary) shift 1; install_apothecary "$@" ;;
    dependencies) shift 1; install_dependencies "$@" ;;
    shared_data) shift 1; install_shared_data "$@" ;;
    example_data) shift 1; install_example_data "$@" ;;
    test_data) shift 1; install_test_data "$@" ;;
    *)
      echoError " Unknown install target: \"$1\""
      echoError " valid: apothecary, dependencies, shared_data, example_data test_data"
      exit 1;;
  esac
  return 0;
}


function generate_project()
{
  PROJECT_PATH=$1

  PROJECT_MAKEFILE=${PROJECT_PATH}/Makefile
  PROJECT_CONFIG_MAKE=${PROJECT_PATH}/config.make
  TEMPLATE_MAKEFILE=${OF_SCRIPTS_PATH}/templates/${HOST_PLATFORM}/Makefile
  TEMPLATE_CONFIG_MAKE=${OF_SCRIPTS_PATH}/templates/${HOST_PLATFORM}/config.make

  if [ ${OF_PROJECT_GENERATOR_AVAILABLE} == true ]; then
    if [ -f ${PROJECT_MAKEFILE} ]; then
      echoWarning "Removing and regenerating ${PROJECT_MAKEFILE} because of https://github.com/openframeworks/projectGenerator/issues/210."
      rm ${PROJECT_MAKEFILE}
    fi

    if [ -f ${PROJECT_CONFIG_MAKE} ]; then
      echoWarning "Removing and regenerating ${PROJECT_CONFIG_MAKE} because of https://github.com/openframeworks/projectGenerator/issues/210."
      rm ${PROJECT_CONFIG_MAKE}
    fi

    ${OF_PROJECT_GENERATOR_COMMAND} -o${OF_ROOT} ${PROJECT_PATH} -p${TARGET_PLATFORM}
  elif [ "${HOST_PLATFORM}" == "${TARGET_PLATFORM}" ] ; then
    echoWarning "Project Generator is not available, creating makefiles."

    PROJECT_PATH_RELATIVE_OF_ROOT=$(realpath --relative-to="${PROJECT_PATH}/.." "${OF_ROOT}")

    if ! [ -f ${PROJECT_MAKEFILE} ]; then
      cp ${TEMPLATE_MAKEFILE} ${PROJECT_PATH}
      sed -i'.bak' -e 's|\.\./\.\.|'${PROJECT_PATH_RELATIVE_OF_ROOT}'|g' ${PROJECT_MAKEFILE}
      rm ${PROJECT_MAKEFILE}.bak
    else
      echoInfo "${PROJECT_PATH} already has a Makefile."
    fi

    if ! [ -f ${PROJECT_CONFIG_MAKE} ]; then
      cp ${TEMPLATE_CONFIG_MAKE} ${PROJECT_PATH}
      sed -i'.bak' -e 's|\.\./\.\.|'${PROJECT_PATH_RELATIVE_OF_ROOT}'|g' ${PROJECT_CONFIG_MAKE}
      rm ${PROJECT_CONFIG_MAKE}.bak
    else
      echoInfo "${PROJECT_PATH} already has a config.make file."
    fi
  else
      echoError "If TARGET_PLATFORM ${TARGET_PLATFORM} != HOST_PLATFORM ${HOST_PLATFORM}, projectGenerator is needed."
      exit 1
  fi
}


function generate_examples()
{
  echoFancy "Generating" "examples"

  while read project; do
      generate_project ${project}
      echoSuccess "Generated example: ${project#"${THIS_ADDON_PATH}/"}"
  done <<< $(find ${THIS_ADDON_PATH}/example* -name addons.make -exec dirname {} \;)
}


function generate_tests()
{
  echoFancy "Generating" "tests"

  while read project; do
    generate_project ${project}
    echoSuccess "Generated example: ${project#"${THIS_ADDON_PATH}/"}"
  done <<< $(find ${THIS_ADDON_PATH}/tests -name addons.make -exec dirname {} \;)

}


function generate()
{
  case "$1" in
    examples) shift 1; generate_examples "$@" ;;
    tests) shift 1; generate_tests "$@" ;;
    all)
      shift 1
      generate_examples "$@"
      generate_tests "$@"
      ;;
    *)
      echoError " Unknown generate target: \"$1\""
      echoError " valid: all, examples, tests"
      exit 1;;
  esac
  return 0;
}


function build_project()
{
  pushd $1 > /dev/null
  make -j${JOBS} -s
  popd > /dev/null
}


function build_examples()
{
  echoFancy "Build" "examples"

  while read project; do
      build_project ${project} $@
      echoSuccess "Built example: ${project#"${THIS_ADDON_PATH}/"}"
  done <<< $(find ${THIS_ADDON_PATH}/example* -name addons.make -exec dirname {} \;)
}


function build_tests()
{
  echoFancy "Build" "tests"

  while read project; do
      build_project ${project} $@
      echoSuccess "Built test: ${project#"${THIS_ADDON_PATH}/"}"
  done <<< $(find ${THIS_ADDON_PATH}/example* -name addons.make -exec dirname {} \;)
}


function build()
{
  case "$1" in
    all)
      shift 1
      build_examples "$@"
      build_tests "$@"
      ;;
    examples) shift 1; build_examples "$@" ;;
    tests) shift 1; build_tests "$@" ;;
    *)
      echoError " Unknown build target: \"$1\""
      echoError " valid: all, examples, tests"
      exit 1;;
  esac
  return 0;
}


function run_project()
{
  PROJECT_PATH=$1
  pushd $PROJECT_PATH > /dev/null
  make -j${JOBS} -s run
  popd > /dev/null
}


function run_examples()
{
  echoFancy "Run" "examples"

  while read project; do
      run_project ${example} $@
      echoSuccess "Ran example: ${example#"${THIS_ADDON_PATH}/"}"
  done <<< $(find ${THIS_ADDON_PATH}/example* -name addons.make -exec dirname {} \;)
}


function run_tests()
{
  echoFancy "Run" "tests"

  while read project; do
      run_project ${project} $@
      echoSuccess "Ran test: ${test#"${THIS_ADDON_PATH}/"}"
  done <<< $(find ${THIS_ADDON_PATH}/example* -name addons.make -exec dirname {} \;)

}


function run()
{
  case "$1" in
    all)
      shift 1
      run_examples "$@"
      run_tests "$@"
      ;;
    examples) shift 1; run_examples "$@" ;;
    tests) shift 1; run_tests "$@" ;;
    *)
      echoError " Unknown run target: \"$1\""
      echoError " valid: all, examples, tests"
      exit 1;;
  esac
  return 0;
}


function bootstrap()
{
  echoFancy "Bootstrapping" "${THIS_ADDON_NAME}"

  echo -e "\n\tüë¢ \033[31;1;4m/ÀàboÕûotÀåstrap/\033[0m - \"a technique of loading a program into a"
  echo -e "\tcomputer by means of a few initial instructions that enable "
  echo -e "\tthe introduction of the rest of the program from an input"
  echo -e "\tdevice.\"\n"

  install_apothecary
  install_dependencies
  install_shared_data
  install_example_data
  install_test_data

  return 0;
}


# handle commands
echoVerbose "Running: $A_CMD $*"
case "$A_CMD" in

  clean)
    clean "$@" ;;
  install)
    install "$@" ;;
  bootstrap)
    bootstrap "$@" ;;
  list)
    list "$@" ;;
  generate)
    generate "$@" ;;
  build)
    build "$@" ;;
  run)
    run "$@" ;;
  *)
    echoError " Unknown command \"$A_CMD\""
    exit 1 ;;
esac



exit 0
