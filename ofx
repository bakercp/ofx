#!/usr/bin/env bash
set -e

#set -x # run script in debug mode
set -o pipefail  # Trace ERR through pipes.
set -o errtrace  # Trace ERR through 'time command' and other functions.
set -o nounset   # set -u : exit the script if you try to use an uninitialized variable.
set -o errexit   # set -e : exit the script if any statement returns a non-true return value.

# Helpful env variables.
DEFAULT_CLONE_DEPTH=1
# export MAKEFLAGS="-s"

# Is verbose?
_VERBOSE=0

HELP="usage: ofx [options] <command> [command parameters]
about:
 This is ofx, the openFrameworks addons multi-tool.
commands:
  ci bootstrap clean generate install list run
options:
  -j The number of jobs (cores) used when compiling (default: 1).
  -t The target platform.
  -p The Project Generator command-line app path.
  -o The openFrameworks root path.
  -h or -? Print this usage guide.
  -v Verbose Mode.
examples:
  ./ofx bootstrap
"

# Trap the killer signals so that we can exit with a good message
trap "trapSignal SIGHUP" SIGHUP
trap "trapSignal SIGINT" SIGINT
trap "trapSignal SIGTERM" SIGTERM

trapSignal() { echo; echoError " Received signal $1"; exit 1; }

# trap any script errors and exit
trap "trapError" ERR

trapError() { echo; echoError " ^ Received error ^"; exit 1; }

# ANSI console escape codes.
CON_DEFAULT="\033[0m"
CON_BOLD="\033[1m"
CON_RED="\033[31m"
CON_YELLOW="\033[33m"
CON_GREEN="\033[32m"
CON_YELLOW_UNDERLINE="\033[33;1;4m"

# Console printing functions (with color)
echoError()   { echo -e "❌  $CON_BOLD$CON_RED$1$CON_DEFAULT"; }
echoWarning() { echo -e "⚠️  $CON_BOLD$CON_YELLOW$1$CON_DEFAULT"; }
echoInfo()    { echo -e "ℹ️  $CON_BOLD$1$CON_DEFAULT"; }
echoSuccess() { echo -e "✅  $CON_BOLD$CON_GREEN$1$CON_DEFAULT"; }
echoVerbose() { if [ $_VERBOSE == 1 ] ; then echoInfo "$1"; fi }
echoFancy() { echo -e "💪  ${1} $CON_YELLOW_UNDERLINE${2}$CON_DEFAULT ..."; }

# Include the Functions.
source "$( dirname "${BASH_SOURCE[0]}" )/lib/functions.sh"

JOBS=$(get_max_number_of_jobs)

# Tutorial: https://wiki.bash-hackers.org/howto/getopts_tutorial

# A POSIX variable
OPTIND=1 # Reset in case getopts has been used previously in the shell.

# When a colon is after an character, that character expects an argument.
while getopts j:p:t:o:hv opt ; do
  case "$opt" in
    j) JOBS=$OPTARG ; ;;
    p) OF_PROJECT_GENERATOR_BIN_PATH=$OPTARG ; ;;
    t) TARGET_PLATFORM=$OPTARG ; ;;
    o) OF_ROOT=$OPTARG ; ;;
    h|\?) echoInfo "$HELP" ; exit 1 ;;
    v) _VERBOSE=1 ;;
  esac
done
shift "$((OPTIND-1))"

# Get the last argument (which must start with ofx or be a path to a folder that starts with ofx)
for arg in $@; do :; done
WORKING_ADDON_PATH=${arg}

# Remove the last argument.
set -- "${@:1:$(($#-1))}"

# Get command.
if [ $# -gt 0 ] ; then
  A_CMD="$1"
else
  echoWarning "Missing command. See help: '$0 -h'."
  exit 1
fi

shift 1

# Some commands don't require targets.
if ! [ "$A_CMD" == "bootstrap" ]; then
  # check for arguments
  if [ $# -lt 1 ] ; then
    echoError " Missing command target. See help: 'ofx -h'."
    exit 1
  fi
fi

# Determine the platform being used.
HOST_PLATFORM=${HOST_PLATFORM:-$(os)}
TARGET_PLATFORM=${TARGET_PLATFORM:-$(os)}


# # TODO: do we want to be this strict?
# if [[ ${WORKING_ADDON_PATH##*/} != ofx* ]]; then 
#   echoError "Addon name does not begin with \"ofx\"."
#   exit 1
# fi

# if [ ! -d $(get_abs_filename $WORKING_ADDON) ]; then 
#   echoError "The addon path does not exist."
#   exit 1
# fi


# Set defaults based on environment.
_CI=${CI:-}
_APPVEYOR=${APPVEYOR:-}
_TRAVIS=${TRAVIS:-}

IS_LOCAL_ADDON=false

if [ ! -z ${_CI} ] && [ "$_CI" == "true" ]; then
  OF_ROOT=${OF_ROOT:-~/openFrameworks}
  if [ ! -z ${_APPVEYOR} ] && [ "$_APPVEYOR" == "true" ]; then
    THIS_ADDON_NAME=${APPVEYOR_PROJECT_SLUG#*/}
    THIS_USERNAME=${APPVEYOR_PROJECT_SLUG%/*}
    THIS_BRANCH=${APPVEYOR_REPO_BRANCH}
  elif [ ! -z ${_TRAVIS} ] && [ "$_TRAVIS" == "true" ]; then
    THIS_ADDON_NAME=${TRAVIS_REPO_SLUG#*/}
    THIS_USERNAME=${TRAVIS_REPO_SLUG%/*}
    THIS_BRANCH=${TRAVIS_BRANCH}
  fi
else
  OF_ROOT=${OF_ROOT:-$(cd "$( dirname "${BASH_SOURCE[0]}" )/../../" && pwd)}
  
  WORKING_ADDON_PATH_ABS=$(get_abs_filename ${WORKING_ADDON_PATH})
  THIS_ADDON_NAME=${WORKING_ADDON_PATH_ABS##*/}
  THIS_USERNAME=$(whoami)
  THIS_BRANCH=$(git rev-parse --abbrev-ref HEAD)

  if [ -d ${WORKING_ADDON_PATH_ABS} ]; then 
    ADDON_PARENT_DIRECTORY=$(basename "$(cd "$( dirname "${WORKING_ADDON_PATH_ABS}" )" && pwd)")
    if [ "${ADDON_PARENT_DIRECTORY}" == "local_addons" ]; then 
      THIS_ADDON_PATH=${WORKING_ADDON_PATH_ABS}
      IS_LOCAL_ADDON=true
    fi  
  elif [[ ${WORKING_ADDON_PATH} != ofx* ]]; then
    echoError "Unable to resolve addon: ${WORKING_ADDON_PATH}"
    exit 1
  fi 
fi

# OF paths.
OF_ADDONS_PATH=${OF_ADDONS_PATH:-${OF_ROOT}/addons}
OF_SCRIPTS_PATH=${OF_SCRIPTS_PATH:-${OF_ROOT}/scripts}
OF_APOTHECARY_PATH=${OF_APOTHECARY_PATH:-${OF_SCRIPTS_PATH}/apothecary}

# Addon paths.
THIS_ADDON_PATH=${THIS_ADDON_PATH:-${OF_ADDONS_PATH}/${THIS_ADDON_NAME}}
THIS_ADDON_SHARED_PATH=${THIS_ADDON_SHARED_PATH:-${THIS_ADDON_PATH}/shared}
THIS_ADDON_SHARED_DATA_PATH=${THIS_ADDON_SHARED_DATA_PATH:-${THIS_ADDON_SHARED_PATH}/data}
THIS_ADDON_SCRIPTS_PATH=${THIS_ADDON_SCRIPTS_PATH:-${THIS_ADDON_PATH}/scripts}

# OF Clone info.
OF_CLONE_DEPTH=${OF_CLONE_DEPTH:-${DEFAULT_CLONE_DEPTH}}
OF_CLONE_BRANCH=${OF_CLONE_BRANCH:-${THIS_BRANCH}}
OF_CLONE_USERNAME=${OF_CLONE_USERNAME:-openFrameworks}

# Addon Clone info.
ADDON_CLONE_DEPTH=${ADDON_CLONE_DEPTH:-${DEFAULT_CLONE_DEPTH}}
ADDON_CLONE_BRANCH=${ADDON_CLONE_BRANCH:-${THIS_BRANCH}}
ADDON_CLONE_USERNAME=${ADDON_CLONE_USERNAME:-${THIS_USERNAME}}

# Project generator info.

if [ "${HOST_PLATFORM}" == "osx" ]; then
  OF_PROJECT_GENERATOR_PATH=${OF_PROJECT_GENERATOR_PATH:-$OF_ROOT/projectGenerator_${HOST_PLATFORM}}
else
  OF_PROJECT_GENERATOR_PATH=${OF_PROJECT_GENERATOR_PATH:-$OF_ROOT/projectGenerator-${HOST_PLATFORM}}
fi

if [ -z ${OF_PROJECT_GENERATOR_BIN_PATH+x} ]; then
    if [ "${HOST_PLATFORM}" == "osx" ]; then
      OF_PROJECT_GENERATOR_BIN_PATH=${OF_PROJECT_GENERATOR_PATH}/projectGenerator.app/Contents/Resources/app/app
    else
      OF_PROJECT_GENERATOR_BIN_PATH=${OF_PROJECT_GENERATOR_PATH}/resources/app/app
    fi
fi

OF_PROJECT_GENERATOR_BIN=projectGenerator
OF_PROJECT_GENERATOR_COMMAND=${OF_PROJECT_GENERATOR_BIN_PATH}/./${OF_PROJECT_GENERATOR_BIN}

if [ -f ${OF_PROJECT_GENERATOR_COMMAND} ]; then
  OF_PROJECT_GENERATOR_AVAILABLE=true
else
  OF_PROJECT_GENERATOR_AVAILABLE=false
fi

if [ $_VERBOSE == 1 ]; then
  echo "================================================================================"
  echo ""
  echo "                          IS_LOCAL_ADDON: ${IS_LOCAL_ADDON}"
  echo "                           HOST_PLATFORM: ${HOST_PLATFORM}"
  echo "                         TARGET_PLATFORM: ${TARGET_PLATFORM}"
  echo ""
  echo "                                     _CI: ${_CI}"
  echo "                               _APPVEYOR: ${_APPVEYOR}"
  echo "                                 _TRAVIS: ${_TRAVIS}"
  echo ""
  echo "                                 OF_ROOT: ${OF_ROOT}"
  echo "                          OF_ADDONS_PATH: ${OF_ADDONS_PATH}"
  echo "                         OF_SCRIPTS_PATH: ${OF_SCRIPTS_PATH}"
  echo "                      OF_APOTHECARY_PATH: ${OF_APOTHECARY_PATH}"
  echo "               OF_PROJECT_GENERATOR_PATH: ${OF_PROJECT_GENERATOR_PATH}"
  echo "           OF_PROJECT_GENERATOR_BIN_PATH: ${OF_PROJECT_GENERATOR_BIN_PATH}"
  echo "                OF_PROJECT_GENERATOR_BIN: ${OF_PROJECT_GENERATOR_BIN}"
  echo "          OF_PROJECT_GENERATOR_AVAILABLE: ${OF_PROJECT_GENERATOR_AVAILABLE}"
  echo ""
  echo "                         THIS_ADDON_NAME: ${THIS_ADDON_NAME}"
  echo "                         THIS_ADDON_PATH: ${THIS_ADDON_PATH}"
  echo "             THIS_ADDON_SHARED_DATA_PATH: ${THIS_ADDON_SHARED_DATA_PATH}"
  echo "                 THIS_ADDON_SCRIPTS_PATH: ${THIS_ADDON_SCRIPTS_PATH}"
  echo ""
  echo "                           THIS_USERNAME: ${THIS_USERNAME}"
  echo "                             THIS_BRANCH: ${THIS_BRANCH}"
  echo ""
  echo "                          OF_CLONE_DEPTH: ${OF_CLONE_DEPTH}"
  echo "                         OF_CLONE_BRANCH: ${OF_CLONE_BRANCH}"
  echo "                       OF_CLONE_USERNAME: ${OF_CLONE_USERNAME}"
  echo ""
  echo "                       ADDON_CLONE_DEPTH: ${ADDON_CLONE_DEPTH}"
  echo "                      ADDON_CLONE_BRANCH: ${ADDON_CLONE_BRANCH}"
  echo "                    ADDON_CLONE_USERNAME: ${ADDON_CLONE_USERNAME}"
  echo ""
  echo "                                    JOBS: ${JOBS}"
  echo "                                _VERBOSE: ${_VERBOSE}"
  echo ""
  echo "================================================================================"
fi

# Include the Helpers.
source "$( dirname "${BASH_SOURCE[0]}" )/lib/apothecary_helper.sh"
source "$( dirname "${BASH_SOURCE[0]}" )/lib/project_helper.sh"
source "$( dirname "${BASH_SOURCE[0]}" )/lib/dependency_helper.sh"

# Clone the list of addons and check to make sure all dependencies are satisfied and cloned.
function clone_addons()
{
  for addon in "$@"
  do
    if [ ! -d ${OF_ADDONS_PATH}/${addon} ]; then
      echoInfo "Installing: ${OF_ADDONS_PATH}/${addon}"
      git clone --quiet --depth=${ADDON_CLONE_DEPTH} -b ${ADDON_CLONE_BRANCH} https://github.com/${ADDON_CLONE_USERNAME}/${addon}.git ${OF_ADDONS_PATH}/${addon}

      # Bootstrap addon if needed.
      pushd ${OF_ADDONS_PATH}/${addon} > /dev/null
      if [ -f scripts/boostrap.sh ]; then
        /usr/bin/env bash scripts/boostrap.sh
      fi
      popd > /dev/null

      local _REQUIRED_ADDONS=$(get_addon_dependencies_for_addon ${OF_ADDONS_PATH}/${addon})

      for required_addon in ${_REQUIRED_ADDONS}
      do
        if [ ! -d ${OF_ADDONS_PATH}/${required_addon} ]; then
          clone_addons ${required_addon}
        else
          echoSuccess "Dependency satisfied: ${required_addon}"
        fi
      done
    else 
      echoSuccess "Dependency satisfied ${addon} by: ${OF_ADDONS_PATH}/${addon}"
    fi
  done
  return 0
}


# Extract ADDON_DEPENDENCIES from an addon's addon_config.mk file.
function get_addon_dependencies_from_addon_config_mk()
{
  if [ -f ${THIS_ADDON_PATH}/addon_config.mk ]; then
    local ADDON_DEPENDENCIES=""
    while read line; do
      if [[ $line == ADDON_DEPENDENCIES* ]] ;
      then
        line=${line#*=}
        IFS=' ' read -ra ADDR <<< "$line"
        for i in "${ADDR[@]}"; do
          ADDON_DEPENDENCIES="${ADDON_DEPENDENCIES} ${i}"
        done
      fi
    done < ${THIS_ADDON_PATH}/addon_config.mk
    echo $(sort_and_remove_duplicates "${ADDON_DEPENDENCIES}")
  fi
  return 0
}


# Extract ADDON_DEPENDENCIES from an project's addons.make files.
function get_addon_dependencies_from_project()
{
  local ADDON_DEPENDENCIES=""
  while read addon; do
    ADDON_DEPENDENCIES="${ADDON_DEPENDENCIES} ${addon}"
  done < "${1}"/addons.make
  echo $(sort_and_remove_duplicates "${ADDON_DEPENDENCIES}")
  return 0
}


function get_addon_dependencies_from_all_projects()
{
  echo $(sort_and_remove_duplicates "$(get_addon_dependencies_from_all_examples) $(get_addon_dependencies_from_all_tests)")
  return 0
}


function get_all_addon_dependencies()
{
  echo $(sort_and_remove_duplicates "$(get_addon_dependencies_from_addon_config_mk) $(get_addon_dependencies_from_all_projects)")
  return 0
}


function install_dependencies()
{
  echoFancy "Installing" "dependencies"
  (clone_addons $(get_all_addon_dependencies))
}


function install_shared_data()
{
  echoFancy "Installing" "shared data"

  if [ -d ${THIS_ADDON_SHARED_DATA_PATH} ] ; then
    SHARED_DATA_SCRIPTS=$(find -L ${THIS_ADDON_SHARED_DATA_PATH} -name *.sh)
    for script in ${SHARED_DATA_SCRIPTS}; do
      /usr/bin/env bash ${script}
    done
  fi
}


function install_data_for_project()
{
    local PROJECT_PATH="$1"
    local did_install=false
    if [ -d ${PROJECT_PATH}/bin/data ] ; then

      DATA_FILES=$(find -L ${PROJECT_PATH}/bin/data -name data.txt)
      for data_file in ${DATA_FILES}
      do
        did_install=true
        # For the project data path.
        THIS_PROJECT_BIN_DATA_PATH=$(dirname "${data_file}")

        # The || [ -n "$line" ]; is to help when the last line isn't a new line char.
        while read line || [ -n "$line" ];
        do
          # Make sure the data doesn't start with a comment hash #
          # Make sure that it isn't am empty line.
          if [ "${line:0:1}" != "#"  ] && [ -n "${line// }" ]; then
            IFS=' ' read -r -a tokens <<< "${line}" # Parse the tokens.
            SRC=${tokens[0]} # Get the source location.
            DST=${tokens[1]:-""} # Get the destination location, or nothing if missing.

            if ! [[ ${SRC} == http* ]]; then
              if [[ ${SRC} == /* ]]; then
                SRC_PATH=${SRC}
              else
                SRC_PATH=${THIS_ADDON_SHARED_DATA_PATH}/${SRC}
              fi

              if [[ -z ${DST} ]]; then
                if [[ ${SRC} == /* ]]; then
                  DST_PATH=${THIS_PROJECT_BIN_DATA_PATH}/$(basename "${SRC}")
                else
                  DST_PATH=${THIS_PROJECT_BIN_DATA_PATH}/${SRC}
                fi
              else
                DST_PATH=${THIS_PROJECT_BIN_DATA_PATH}/${DST}
              fi

              if ! [ -e ${DST_PATH} ]; then
                if ! [ -e ${SRC_PATH} ]; then
                  echo "❌ ${SRC_PATH} does not exist. Did you install the shared data?"
                  continue
                fi

                mkdir -p "$(dirname "${DST_PATH}")"
                rsync -Pvqar ${SRC_PATH} ${DST_PATH}
              fi

              echo "✅ ${SRC_PATH} 👉 ${DST_PATH}"
            else
              if [[ -z ${DST} ]]; then
                DST=$(basename ${SRC})
              fi
              DST_PATH=${THIS_PROJECT_BIN_DATA_PATH}/${DST}
              if ! [ -e ${DST_PATH} ]; then
                curl --progress-bar --create-dirs -o ${DST_PATH} -L ${SRC}
              fi
              echo "✅ ${SRC} 👉 ${DST_PATH}"
            fi
          fi
        done < ${data_file}
      done
    fi

    if [ ${did_install} == "true" ]; then
      echoSuccess "Installed data for: ${PROJECT_PATH#"${THIS_ADDON_PATH}/"}"
    else
      echoInfo "No shared data for: ${PROJECT_PATH#"${THIS_ADDON_PATH}/"}"
    fi
}


function list()
{
  case "$1" in
    examples) shift 1; list_examples "$@" ;;
    addon_dependencies) shift 1; list_addon_dependencies "$@" ;;
    tests) shift 1; list_tests "$@" ;;
    dependencies) shift 1; get_all_addon_dependencies "$@" ;;
    *)
      echoError " Unknown list target: \"$1\""
      echoError " valid: examples, addon_dependencies, tests"
      exit 1 ;;
  esac
}


function clean()
{
  case "$1" in
    all)
      shift 1
      clean_apothecary "$@"
      clean_example_project_files "$@"
      clean_test_project_files "$@"
      clean_example_build_files "$@"
      clean_test_build_files "$@"
      ;;
    apothecary) shift 1; clean_apothecary "$@" ;;
    example_project_files) shift 1; clean_example_project_files "$@" ;;
    test_project_files) shift 1; clean_test_project_files "$@" ;;
    example_build_files) shift 1; clean_example_build_files "$@" ;;
    test_build_files) shift 1; clean_example_build_files "$@" ;;
    projects)
      shift 1
      clean_example_project_files "$@"
      clean_test_project_files "$@"
      ;;
    build)
      shift 1
      clean_example_build_files "$@"
      clean_test_build_files "$@"
      ;;
    *)
      echoError " Unknown clean target: \"$1\""
      echoError " valid: all, apothecary, example_project_files, test_project_files, example_build_files, test_build_files, projects, build"
      exit 1 ;;
  esac
}


function install()
{
  case "$1" in
    apothecary) shift 1; install_apothecary "$@" ;;
    dependencies) shift 1; install_dependencies "$@" ;;
    libraries) shift 1; install_libraries "$@" ;;
    openframeworks) shift 1; install_openframeworks "$@" ;;
    shared_data) shift 1; install_shared_data "$@" ;;
    example_data) shift 1; install_example_data "$@" ;;
    test_data) shift 1; install_test_data "$@" ;;
    *)
      echoError " Unknown install target: \"$1\""
      echoError " valid: apothecary, dependencies, libraries, openframeworks, shared_data, example_data test_data"
      exit 1;;
  esac
}


function generate_examples()
{
  (do_function_for_projects generate_project "${EXAMPLE_PROJECTS}" $@)
}


function generate_tests()
{
  (do_function_for_projects generate_project "${TEST_PROJECTS}" $@)
}


function generate_all()
{
  (generate_examples $@)
  (generate_tests $@)
}


function generate()
{
  case "$1" in
    examples) shift 1; generate_examples "$@" ;;
    tests) shift 1; generate_tests "$@" ;;
    all)
      shift 1
      generate_examples "$@"
      generate_tests "$@"
      ;;
    *)
      echoError " Unknown generate target: \"$1\""
      echoError " valid: all, examples, tests"
      exit 1;;
  esac
}


function build_examples()
{
  (do_function_for_projects build_project "${EXAMPLE_PROJECTS}" $@)
}


function build_tests()
{
  (do_function_for_projects build_project "${TEST_PROJECTS}" $@)
}

function build_all()
{
  (build_examples $@)
  (build_tests $@)
}

function build()
{
  case "$1" in
    all)
      shift 1
      build_all "$@"
      ;;
    examples) shift 1; build_examples "$@" ;;
    tests) shift 1; build_tests "$@" ;;
    *)
      echoError " Unknown build target: \"$1\""
      echoError " valid: all, examples, tests"
      exit 1;;
  esac
}


function run_examples()
{
  (do_function_for_projects run_project "${EXAMPLE_PROJECTS}" $@)
}


function run_tests()
{
  (do_function_for_projects run_project "${TEST_PROJECTS}" $@)
}

function run_all()
{
  (run_examples $@)
  (run_tests $@)
}

function run()
{
  case "$1" in
    all)
      shift 1
      run_all "$@"
      ;;
    examples) shift 1; run_examples "$@" ;;
    tests) shift 1; run_tests "$@" ;;
    *)
      echoError " Unknown run target: \"$1\""
      echoError " valid: all, examples, tests"
      exit 1;;
  esac
}


function bootstrap()
{
  echoFancy "Bootstrapping" "${THIS_ADDON_NAME}"

  echo -e "\n\t👢 \033[31;1;4m/ˈbo͞otˌstrap/\033[0m - \"a technique of loading a program into a"
  echo -e "\tcomputer by means of a few initial instructions that enable "
  echo -e "\tthe introduction of the rest of the program from an input"
  echo -e "\tdevice.\"\n"

  install_apothecary
  install_libraries
  install_dependencies
  install_shared_data
  install_example_data
  install_test_data
  generate_all "force"
}


function ci_install()
{
  echoFancy "CI" "Install"

  # Check to see if we are running in a CI server / environment.
  if [ "${_CI}" == "true" ]; then
    if [ "${_TRAVIS}" == "true" ]; then

      echoFancy "Installing" "openFrameworks"
      if [ ! -d ${OF_ROOT} ]; then
          git clone --depth=${OF_CLONE_DEPTH} --branch=${OF_CLONE_BRANCH} https://github.com/${OF_CLONE_USERNAME}/openFrameworks.git ${OF_ROOT}
          pushd ${OF_ROOT} > /dev/null
          scripts/ci/addons/install.sh

          # After this, the cloned addon will be in $THIS_ADDON_PATH, so make a link.
          if [ ! -L ${THIS_ADDON_PATH} ]; then 
            ln -s ${THIS_ADDON_PATH} ${TRAVIS_BUILD_DIR}
          fi

          popd > /dev/null
      else 
          echoWarning "${OF_ROOT} already exists"
      fi
    fi
  fi 


}


function ci_script()
{
  echoFancy "CI" "Run"

  # Run bootstrap (see above).
  bootstrap

  # Build all projects, including examples.
  build_all

  # Run tests, but not examples as many examples require a window.
  run_tests
}


function ci()
{
  case "$1" in
    install)
      shift 1
      ci_install "$@"
      ;;
    script) 
      shift 1
      ci_script "$@" 
      ;;
    *)
      echoError " Unknown ci target: \"$1\""
      echoError " valid: install, script"
      exit 1;;
  esac
}


# handle commands
echoVerbose "Running: $A_CMD $*"
case "$A_CMD" in

  ci)
    ci "$@" ;;
  clean)
    clean "$@" ;;
  install)
    install "$@" ;;
  bootstrap)
    bootstrap "$@" ;;
  list)
    list "$@" ;;
  generate)
    generate "$@" ;;
  build)
    build "$@" ;;
  run)
    run "$@" ;;
  *)
    echoError " Unknown command \"$A_CMD\""
    exit 1 ;;
esac


exit 0
